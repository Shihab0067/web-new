document.addEventListener("DOMContentLoaded", function() {
    const newsletterForm = document.querySelector("f-popup-newsletter-form");
    let submittedEmail = '';

    function log(msg) {
        // La funzione log non ha il prefisso perché è generica per questo file.
        const logDiv = document.getElementById("log");
        if (!logDiv) return;
        const p = document.createElement("p");
        p.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        logDiv.appendChild(p);
    }

    async function fetchCategories() {
        log("fetchCategories: Chiamata a getCategories iniziata.");
        try {
            const data = await fetchJSON(API_PATHS.newsletter, { action: 'getCategories' });
            if (!data || !Array.isArray(data.categories)) {
                log("fetchCategories: Errore: la risposta delle categorie non è un array valido.");
                return;
            }
            const transformedData = buildCategories(data.categories);
            if (newsletterForm) {
                newsletterForm.setAttribute("guids", JSON.stringify(transformedData));
            }
            console.log(`fetchCategories: Categorie caricate con successo. ${transformedData.length} elementi elaborati.`);
        } catch (err) {
            // log(`fetchCategories: Errore durante il caricamento delle categorie: ${err.message || err}`);
            // console.error(err);

           // log("fetchCategories: Errore durante il caricamento delle categorie, utilizzo i dati di fallback.");
            const fallbackResponse = {
                "categories": [
                    {
                        "code": "STORE",
                        "guidNewsletter": "STORE",
                        "active": true
                    },
                    {
                        "code": "F1",
                        "guidNewsletter": "F1",
                        "active": true
                    },
                    {
                        "code": "GT",
                        "guidNewsletter": "GT",
                        "active": true
                    },
                    {
                        "code": "ESPORTS",
                        "guidNewsletter": "ESPORTS",
                        "active": true
                    },
                    {
                        "code": "RACES",
                        "guidNewsletter": "RACES",
                        "active": true
                    }
                ]
            };
            const transformedData = buildCategories(fallbackResponse.categories);
            if (newsletterForm) {
                newsletterForm.setAttribute("guids", JSON.stringify(transformedData));
            }
            //console.log(`fetchCategories: Categorie caricate con successo (da fallback). ${transformedData.length} elementi elaborati.`);
        }
    }

    async function resendLink() {
        if (!submittedEmail) {
            log("resendLink: Errore: non è stata salvata nessuna email per il resend.");
            return;
        }

        const payload = {
            email: submittedEmail,
            type: "newsletter"
        };

        log("resendLink: Chiamata a resendLink iniziata con il seguente payload:");
        log(JSON.stringify(payload, null, 2));

        const url = new URL(API_PATHS.newsletter);
        url.searchParams.append('action', 'resendLink');

        try {
            await fetchPostJSON(url.href, payload);
            log("resendLink: Resend Link eseguito con successo.");
        } catch (error) {
            log("resendLink: La chiamata di resendLink è fallita.");
            console.error("Errore durante il resendLink:", error);
        }
    }

    async function subscribe(payload) {
        if (!payload) { log("subscribe: Errore: payload non fornito per l'iscrizione."); return; }
        log("subscribe: Chiamata a subscribe iniziata con il seguente payload:");
        log(JSON.stringify(payload, null, 2));
        const url = new URL(API_PATHS.newsletter);
        url.searchParams.append('action', 'subscribe');
        // Aggiungo un try-catch qui per non avere errori di 'unhandled promise rejection' nella console
        try {
            await fetchPostJSON(url.href, payload);
            log("subscribe: Chiamata in background completata.");
        } catch(e) {
            log("subscribe: Chiamata in background fallita. L'utente non lo saprà.");
            console.error("Errore subscribe in background:", e);
        }
    }

    function buildCategories(categoriesData) {
        if (!Array.isArray(categoriesData)) { log("buildCategories: i dati ricevuti non sono un array."); return []; }
        const outputArray = [];
        let idCounter = 1;
        categoriesData.forEach(item => {
            if (item.code !== "ALL" && item.code !== "OTHER" && item.code !== "STORE") {
                const transformedItem = { Description: item.code, GuidNewsLetter: item.guidNewsletter, IdNewsLetter: idCounter, Order: item.order };
                outputArray.push(transformedItem);
                idCounter++;
            }
        });
        return outputArray;
    }

    function setupFormListener() {
        if (!newsletterForm) {
            log("setupFormListener: Elemento 'f-popup-newsletter-form' non trovato nella pagina.");
            return;
        }

        customElements.whenDefined('f-popup-newsletter-form').then(() => {
            const shadowRoot = newsletterForm.shadowRoot;
            if (!shadowRoot) {
                log("setupFormListener: Errore: impossibile accedere allo Shadow DOM del form.");
                return;
            }

            const submitButton = shadowRoot.querySelector('f-button[type="submit"]');
            if (!submitButton) {
                log("setupFormListener: Errore: pulsante di submit non trovato nello Shadow DOM.");
                return;
            }

            log("setupFormListener: Listener di produzione impostato correttamente.");

            submitButton.addEventListener('mousedown', (event) => {
                event.preventDefault();
                event.stopPropagation();

                log("setupFormListener: Pulsante 'Subscribe' premuto.");

                submitButton.disabled = true;

                const emailWrapper = shadowRoot.querySelector('f-text-input');
                const emailInput = emailWrapper ? emailWrapper.querySelector('input[type="email"]') : null;
                const email = emailInput ? emailInput.value : '';

                submittedEmail = email;

                const newsletterWrappers = shadowRoot.querySelectorAll('f-checkbox-input');
                const selectedCodes = Array.from(newsletterWrappers)
                    .map(wrapper => wrapper.querySelector('input[type="checkbox"]'))
                    .filter(input => input && input.checked)
                    .map(input => input.id);

                const consentWrappers = shadowRoot.querySelectorAll('f-radio-input');
                const checkedConsentInput = Array.from(consentWrappers)
                    .map(wrapper => wrapper.querySelector('input[type="radio"]'))
                    .find(input => input && input.checked);
                const consentValue = checkedConsentInput ? checkedConsentInput.value === 'true' : false;

                const formattedNewsletters = selectedCodes.map(code => ({ code: code }));
                const formattedConsents = [{ type: "agreement_privacy", value: consentValue, idConsentApp: "AUTO" }];
                const payload = { newsletters: formattedNewsletters, email: email, source: "subscribeAll", consents: formattedConsents };

                log("setupFormListener: Mostro la schermata di successo e avvio la chiamata in background.");
                newsletterForm.submitted = true;

                subscribe(payload);

                setTimeout(() => {
                    const resendButton = shadowRoot.querySelector('button.f-popup-newsletter-form_resend');
                    if (resendButton) {
                        resendButton.addEventListener('click', resendLink);
                        log("setupFormListener: Listener per il pulsante 'Resend' attivato.");
                    } else {
                        log("setupFormListener: Attenzione: pulsante 'Resend' non trovato dopo il submit.");
                    }
                }, 500);

            });
        });
    }



    fetchCategories();
    setupFormListener();
});
